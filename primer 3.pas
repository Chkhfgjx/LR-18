uses crt;
{Узел = вершина}
const
  N = 500; { количество элементов в дереве }
 
{ Инициализация  дерева }
{ val - текущая вершина, left, right -  левый и правый сыновья соответственно }
type
  tree = record
    val, left, right: integer;
    flagL, flagR: boolean; { флаги для метки просмотренных вершин }
  end;
    { массив + вершина со ссылками на двух сыновей = дерево }
  artree = array [1..N] of tree;
  

var
  i: integer;
  a: artree;
  q: char;
 
procedure FormTree(var i: integer; var a: artree);
{
 Формирует дерево при помощи массива записей
 i - счетчик узлов в дереве;
 a - само дерево
}
var
  j: integer;
begin
    {
     Добавление узла в дерево.
     Вначале значение узла записывает в ячейку массива,
     далее определятся, к какому узлу (вернее к какому сыну (левому или
     правому)) оно должно принадлежать
     (его индекс записывается в одну из двух (левого или правого)
     ячеек элемента, к которому он будет привязан)
    }
  if a[1].val = 0 then
  begin
    write('Корень: ');
    readln(a[1].val); { ввод корня дерева }
    i := 1;
  end
  else
  begin
    inc(i); { переходим к следующей ячейке массива для ее заполнения }
    j := 1; { индекс добавляющего узла }
    write('Узел #', i, ': ');
    readln(a[i].val); { ввод последующих узлов }
    while true do
    begin
              {---Добавление узла к вершине "справа"---}
      { сравнение текущего узла с добавляемым }
      if a[i].val >= a[j].val then
      begin
        if a[j].right = 0 then { у этого узла нет сына }
        begin
          a[j].right := i; { добавляем индекс добавляемого узла }
          break; { выходим из цикла для последующего добавления }
        end
                else { иначе }
        if a[j].right <> 0 then
        begin
                    {
                     узнаем индекс элемента,
                     стоящего на месте занятой вершины.
                     Этот элемент станет текущим.
                     Продолжаем поиск
                    }
          j := a[j].right;
          continue;
        end;
      end;
            {---Добавление узла к вершине "слева"---}
            { сравнение текущего узла с добавляемым }
      if a[i].val < a[j].val then
      begin
        if a[j].left = 0 then { у этого узла нет сына }
        begin
          a[j].left := i; { добавляем индекс добавляемого узла }
          break;
        end
                else { иначе }
        if a[j].left <> 0 then
        begin
                     {
                     узнаем индекс элемента,
                     стоящего на месте занятой вершины.
                     Этот элемент станет текущим.
                     Продолжаем поиск
                    }
          j := a[j].left;
          continue;
        end;
      end;
    end;
  end;
end;
 
procedure PrintTree(i: integer);
{ Вывод дерева в табличном виде }
var
  k, x, y: integer;
begin
  x := 13; { кооординаты курсора по оси x }
  y := 1;
  if a[1].val = 0 then { проверяем наличие корня }
    writeln('Дерево пусто')
    else
  begin
    clrscr; { очищаем экран, чтоб корректно работала gotoxy }
    writeln('Вершина:    ');
    writeln('Левый сын:  ');
    writeln('Правый сын: ');
    for k := 1 to i do
    begin
      gotoxy(x, y); { переходим к нужной позиции }
      { выводим вершины }
      write(a[k].val:3, ' |');
      
        { выводим их левых сыновей }
      gotoxy(x, y + 1); { переходим к нужной позиции }
      if a[k].left <> 0 then
        write(a[a[k].left].val:3, ' |')
      else
        write('nil |');
      gotoxy(x, y + 2); { переходим к нужной позиции }
        { выводим их правых сыновей }
      if a[k].right <> 0 then
        write(a[a[k].right].val:3, ' |')
      else
        write('nil |');
      { когда элемент = 0 - это все равно, что он
      отсутствует (поэтому выводится на экран как значение nil)
      }
      x := x + 5; { добавляем отступ от предыдущих выведеных значений }
      if x >= 70 then { если элементам не хватает места на
                     одной строке - переносим на другую }
      begin
        gotoxy(x, y + 1);
        write(' --->');
        gotoxy(1, 5);
        writeln('Вершина:    ');
        writeln('Левый сын:  ');
        writeln('Правый сын: ');
        y := y + 4;
        x := 13;
      end;
    end;
  end;
  readln;
  clrscr; { очищаем экран }
end;
 
procedure List(n: integer; a: artree);
{
 Формирует список узлов при прямом обходе
 n - количество узлов в дереве;
 a - само дерево
}
var
  i, j, k: integer;
    {
     bufInd содержит адреса (индексы) узлов с
     не полностью просмотренными сыновьями
    }
  bufInd: array [0..1000] of integer;
begin
  writeln('Список узлов при прямом обходе: ');
  i := 0; { массив индексов начинается с 0, обнуляем }
  j := 0; { счетчик просмотренных узлов в дереве }
  k := 1; { массив узлов начинается с 1 }
  write(a[k].val:3); { выводим на экран первый элемент, он же корень дерева }
  while j <> n do { пока не будут просмотрены все вершины }
  begin
    if (a[k].flagl = false) or (a[k].flagr = false) then
            { левый сын текущей вершины существует и еще не просмотрен }
      if (a[k].left <> 0) and (a[k].flagl = false) then
      begin
        a[k].flagl := true; { отмечаем просмотренный узел }
        if a[k].right = 0 then { заодно проверяем, отсутствует
                                ли левый сын, если да, то: }
        begin
          a[k].flagr := true; { отмечаем просмотренный узел }
          inc(j); { узел просмотрен, прибавляем }
        end
                else { иначе }
        begin
          bufind[i] := k; { запоминаем его индекс, чтоб впоследствии вернуться }
          inc(i); { счетчик для массива индексов }
          inc(j); { узел просмотрен, прибавляем }
        end;
        k := a[k].left; { переходим на левого сына текущего узла }
        write(a[k].val:3); { выводим на экран вершину }
      end
            else { иначе }
            { левый сын текущей вершины существует и еще не просмотрен }
      if (a[k].right <> 0) and (a[k].flagr = false) then
      begin
        a[k].flagr := true; { отмечаем просмотренный узел }
        if a[k].left = 0 then { заодно проверяем, отсутствует
                                ли левый сын, если да, то: }
        begin
          a[k].flagl := true; { отмечаем просмотренный узел }
          inc(j); { узел просмотрен, прибавляем }
        end;
        k := a[k].right; { переходим на правого сына текущего узла }
        write(a[k].val:3); { выводим на экран вершину }
      end
            else { иначе }
            { когда текущая вершина не имеет сыновей) }
      begin
        dec(i); { в "массиве индексов" переходим на элемент,
                  который является индексом одной из вершин,
                  у которой не просмотрен один из сыновей
                }
        if i >= 0 then { предотвращение выхода за границы диапазона }
          k := bufind[i]; { переходим на элемент с одним из не просмотренных сыновей }
        inc(j); { узел просмотрен, прибавляем }
      end;
  end;
  writeln;
end;
 
procedure depth(n: integer; a: artree);
{
 Выводит все возможные пути от корня к листам,
 а также указывает глубину - самый длинный путь
}
var
  i, j, j1, k, kol: integer;
  p: boolean; { нужен для сообщения направления из вершины }
    {
     bufInd содержит адреса (индексы) узлов с
     не полностью просмотренными сыновьями
    }
  bufInd: array [0..1000] of integer;
begin
  writeln('Все возможные пути:');
    { узнаем количество путей в дереве}
  kol := 0; { обнуляем счетчик }
  for i := 1 to n do
    if (a[i].left = 0) and (a[i].right = 0) then
      inc(kol);
  j1 := 0; { нужна для сравнения путей }
  i := 0; { массив индексов начинается с 0}
  j := 0; { счетчик просмотренных узлов в дереве }
  k := 1; { массив узлов начинается с 1 }
  while kol <> 0 do { пока не будут пройдены все пути }
  begin
        {
         левый сын текущей вершины существует,
         а также через него существует непросмотренный путь
        }
    if (a[k].left <> 0) and (a[k].flagl = false) then
    begin
      if a[k].right = 0 then { заодно проверяем, отсутствует ли правый сын }
        inc(j) { если да, то добавляем в счетчик }
            else { иначе }
      begin
        bufind[i] := k; { запоминаем его индекс, чтоб впоследствии вернуться }
        p := true; { и пойти именно по этому пути }
        inc(i); { счетчик для массива индексов }
        inc(j); { узел просмотрен, прибавляем }
      end;
      k := a[k].left; { переходим на левого сына текущего узла }
    end
        else { иначе  }
        {
         правый сын текущей вершины существует,
         а также через него существует непросмотренный путь
        }
    if (a[k].right <> 0) and (a[k].flagr = false) then
    begin
      inc(j); { узел просмотрен, прибавляем }
      k := a[k].right; { переходим на правого сына текущего узла }
    end
        else { когда текущая вершина не имеет сыновей) }
    begin
      dec(i); { в "массиве индексов" переходим на элемент,
                  который является индексом одной из вершин,
                  у которой не просмотрен один из сыновей
                }
      if i >= 0 then { предотвращение выхода за границы диапазона }
        if p = true then {влево уже ходили}
          a[bufind[i]].flagl := true { больше не пойдем }
        else {вправо уже ходили}
          a[bufind[i]].flagr := true; { больше не пойдем }
      write(j, ' '); { выводим на экран длину пути }
      
      if j > j1 then { ищем наибольший из путей }
        j1 := j;
      j := 0; { обнуляем счетчик просмотренных вершин }
      k := 1; { переходим к корню дерева }
      p := false; { возвращаем флаг в исходное состояние }
      dec(kol); { путь просмотрен, вычитаем из общего количества}
    end;
  end;
  writeln;
  writeln('Глубина = ', j1); { выводим глубину дерева }
end;
 
begin
  while true do
  begin
    writeln('-----------------------------------------------------------------------');
    writeln('1-Добавить узел; 2-Просмотр дерева; 3-Список узлов; 4-Глубина; 5-Выход;');
    writeln('-----------------------------------------------------------------------');
    readln(q);
    case q of
      '1': FormTree(i, a);
      '2': PrintTree(i);
      '3': List(i, a);
      '4': Depth(i, a);
      '5': break;
    end;
  end;
end.